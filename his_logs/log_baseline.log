(base) root@autodl-container-664048b698-da024dca:~/EAAE# torchrun --nproc_per_node=4 baseline_bc5_finetune.py
Some weights of BertForSequenceClassification were not initialized from the model checkpoint at dmis-lab/biobert-base-cased-v1.1 and are newly initialized: ['classifier.bias', 'classifier.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
Some weights of BertForSequenceClassification were not initialized from the model checkpoint at dmis-lab/biobert-base-cased-v1.1 and are newly initialized: ['classifier.bias', 'classifier.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
Some weights of BertForSequenceClassification were not initialized from the model checkpoint at dmis-lab/biobert-base-cased-v1.1 and are newly initialized: ['classifier.bias', 'classifier.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
Some weights of BertForSequenceClassification were not initialized from the model checkpoint at dmis-lab/biobert-base-cased-v1.1 and are newly initialized: ['classifier.bias', 'classifier.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
/root/EAAE/baseline_bc5_finetune.py:109: FutureWarning: `tokenizer` is deprecated and will be removed in version 5.0.0 for `Trainer.__init__`. Use `processing_class` instead.
  trainer = Trainer(
/root/EAAE/baseline_bc5_finetune.py:109: FutureWarning: `tokenizer` is deprecated and will be removed in version 5.0.0 for `Trainer.__init__`. Use `processing_class` instead.
  trainer = Trainer(
/root/EAAE/baseline_bc5_finetune.py:109: FutureWarning: `tokenizer` is deprecated and will be removed in version 5.0.0 for `Trainer.__init__`. Use `processing_class` instead.
  trainer = Trainer(
/root/EAAE/baseline_bc5_finetune.py:109: FutureWarning: `tokenizer` is deprecated and will be removed in version 5.0.0 for `Trainer.__init__`. Use `processing_class` instead.
  trainer = Trainer(
  0%|                                                                                                                                                                                                                                                | 0/3455 [00:00<?, ?it/s]/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
[rank3]:[W reducer.cpp:1360] Warning: find_unused_parameters=True was specified in DDP constructor, but did not find any unused parameters in the forward pass. This flag results in an extra traversal of the autograd graph every iteration,  which can adversely affect performance. If your model indeed never has any unused parameters in the forward pass, consider turning this flag off. Note that this warning may be a false positive if your model has flow control causing later iterations to have unused parameters. (function operator())
[rank0]:[W reducer.cpp:1360] Warning: find_unused_parameters=True was specified in DDP constructor, but did not find any unused parameters in the forward pass. This flag results in an extra traversal of the autograd graph every iteration,  which can adversely affect performance. If your model indeed never has any unused parameters in the forward pass, consider turning this flag off. Note that this warning may be a false positive if your model has flow control causing later iterations to have unused parameters. (function operator())
[rank2]:[W reducer.cpp:1360] Warning: find_unused_parameters=True was specified in DDP constructor, but did not find any unused parameters in the forward pass. This flag results in an extra traversal of the autograd graph every iteration,  which can adversely affect performance. If your model indeed never has any unused parameters in the forward pass, consider turning this flag off. Note that this warning may be a false positive if your model has flow control causing later iterations to have unused parameters. (function operator())
[rank1]:[W reducer.cpp:1360] Warning: find_unused_parameters=True was specified in DDP constructor, but did not find any unused parameters in the forward pass. This flag results in an extra traversal of the autograd graph every iteration,  which can adversely affect performance. If your model indeed never has any unused parameters in the forward pass, consider turning this flag off. Note that this warning may be a false positive if your model has flow control causing later iterations to have unused parameters. (function operator())
{'loss': 0.5214, 'grad_norm': 4.4033203125, 'learning_rate': 1.9143270622286542e-05, 'epoch': 0.22}                                                                                                                                                                           
{'loss': 0.2568, 'grad_norm': 4.94504976272583, 'learning_rate': 1.827496382054993e-05, 'epoch': 0.43}                                                                                                                                                                        
{'loss': 0.1691, 'grad_norm': 2.945110321044922, 'learning_rate': 1.7412445730824895e-05, 'epoch': 0.65}                                                                                                                                                                      
{'loss': 0.1169, 'grad_norm': 2.767620086669922, 'learning_rate': 1.654413892908828e-05, 'epoch': 0.87}                                                                                                                                                                       
{'eval_precision': 0.7002171413973688, 'eval_recall': 0.7005750798722045, 'eval_f1': 0.700396064903539, 'eval_loss': 0.7621352076530457, 'eval_runtime': 33.2817, 'eval_samples_per_second': 1427.27, 'eval_steps_per_second': 11.177, 'epoch': 1.0}                          
 20%|██████████████████████████████████████████████                                                                                                                                                                                        | 691/3455 [02:04<06:25,  7.18it/s/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
{'loss': 0.0816, 'grad_norm': 2.795628070831299, 'learning_rate': 1.5675832127351665e-05, 'epoch': 1.09}                                                                                                                                                                      
{'loss': 0.0582, 'grad_norm': 3.004084825515747, 'learning_rate': 1.480752532561505e-05, 'epoch': 1.3}                                                                                                                                                                        
{'loss': 0.0474, 'grad_norm': 5.431288719177246, 'learning_rate': 1.3945007235890016e-05, 'epoch': 1.52}                                                                                                                                                                      
{'loss': 0.0371, 'grad_norm': 0.4223088026046753, 'learning_rate': 1.3076700434153401e-05, 'epoch': 1.74}                                                                                                                                                                     
{'loss': 0.0336, 'grad_norm': 0.3927232027053833, 'learning_rate': 1.2208393632416788e-05, 'epoch': 1.95}                                                                                                                                                                     
{'eval_precision': 0.7149854381784485, 'eval_recall': 0.690223642172524, 'eval_f1': 0.7023863710254242, 'eval_loss': 1.1964083909988403, 'eval_runtime': 33.4607, 'eval_samples_per_second': 1419.636, 'eval_steps_per_second': 11.118, 'epoch': 2.0}                         
 40%|███████████████████████████████████████████████████████████████████████████████████████████▌                                                                                                                                         | 1382/3455 [04:11<04:45,  7.27it/s/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
{'loss': 0.0238, 'grad_norm': 0.062378741800785065, 'learning_rate': 1.1340086830680175e-05, 'epoch': 2.17}                                                                                                                                                                   
{'loss': 0.0224, 'grad_norm': 2.2291340827941895, 'learning_rate': 1.0471780028943562e-05, 'epoch': 2.39}                                                                                                                                                                     
{'loss': 0.0188, 'grad_norm': 0.03161457180976868, 'learning_rate': 9.603473227206947e-06, 'epoch': 2.6}                                                                                                                                                                      
{'loss': 0.0164, 'grad_norm': 0.3117915987968445, 'learning_rate': 8.735166425470334e-06, 'epoch': 2.82}                                                                                                                                                                      
{'eval_precision': 0.6898254063816978, 'eval_recall': 0.7321405750798722, 'eval_f1': 0.7103533787972721, 'eval_loss': 1.4092398881912231, 'eval_runtime': 33.7898, 'eval_samples_per_second': 1405.809, 'eval_steps_per_second': 11.009, 'epoch': 3.0}                        
 60%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▍                                                                                           | 2073/3455 [06:18<03:01,  7.60it/s/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
{'loss': 0.0144, 'grad_norm': 0.2431027889251709, 'learning_rate': 7.872648335745298e-06, 'epoch': 3.04}                                                                                                                                                                      
{'loss': 0.0118, 'grad_norm': 0.06553138047456741, 'learning_rate': 7.004341534008684e-06, 'epoch': 3.26}                                                                                                                                                                     
{'loss': 0.0087, 'grad_norm': 0.10165315121412277, 'learning_rate': 6.136034732272071e-06, 'epoch': 3.47}                                                                                                                                                                     
{'loss': 0.0072, 'grad_norm': 0.5986838340759277, 'learning_rate': 5.267727930535457e-06, 'epoch': 3.69}                                                                                                                                                                      
{'loss': 0.0094, 'grad_norm': 0.0021955776028335094, 'learning_rate': 4.399421128798843e-06, 'epoch': 3.91}                                                                                                                                                                   
{'eval_precision': 0.6785110968719054, 'eval_recall': 0.7442811501597444, 'eval_f1': 0.7098759789133681, 'eval_loss': 1.6068203449249268, 'eval_runtime': 33.9574, 'eval_samples_per_second': 1398.869, 'eval_steps_per_second': 10.955, 'epoch': 4.0}                        
 80%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▏                                             | 2764/3455 [08:23<01:35,  7.22it/s/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
{'loss': 0.0056, 'grad_norm': 0.0050799730233848095, 'learning_rate': 3.531114327062229e-06, 'epoch': 4.12}                                                                                                                                                                   
{'loss': 0.0068, 'grad_norm': 6.348847389221191, 'learning_rate': 2.6628075253256154e-06, 'epoch': 4.34}                                                                                                                                                                      
{'loss': 0.0047, 'grad_norm': 0.682856559753418, 'learning_rate': 1.7945007235890016e-06, 'epoch': 4.56}                                                                                                                                                                      
{'loss': 0.0032, 'grad_norm': 0.030124792829155922, 'learning_rate': 9.261939218523879e-07, 'epoch': 4.78}                                                                                                                                                                    
{'loss': 0.0044, 'grad_norm': 0.0019341781735420227, 'learning_rate': 5.788712011577424e-08, 'epoch': 4.99}                                                                                                                                                                   
{'eval_precision': 0.6778515737799595, 'eval_recall': 0.7499680511182109, 'eval_f1': 0.7120885787956924, 'eval_loss': 1.631087064743042, 'eval_runtime': 33.8865, 'eval_samples_per_second': 1401.798, 'eval_steps_per_second': 10.978, 'epoch': 5.0}                         
{'train_runtime': 631.964, 'train_samples_per_second': 349.775, 'train_steps_per_second': 5.467, 'train_loss': 0.0642420316786221, 'epoch': 5.0}                                                                                                                              
100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 3455/3455 [10:31<00:00,  5.47it/s]
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 372/372 [00:33<00:00, 13.34it/s]Dev set results: {'eval_precision': 0.6778515737799595, 'eval_recall': 0.7499680511182109, 'eval_f1': 0.7120885787956924, 'eval_loss': 1.631087064743042, 'eval_runtime': 33.1768, 'eval_samples_per_second': 1431.783, 'eval_steps_per_second': 11.213, 'epoch': 5.0}
Dev set results: Dev set results: {'eval_precision': 0.6778515737799595, 'eval_recall': 0.7499680511182109, 'eval_f1': 0.7120885787956924, 'eval_loss': 1.631087064743042, 'eval_runtime': 33.1764, 'eval_samples_per_second': 1431.8, 'eval_steps_per_second': 11.213, 'epoch': 5.0}
{'eval_precision': 0.6778515737799595, 'eval_recall': 0.7499680511182109, 'eval_f1': 0.7120885787956924, 'eval_loss': 1.631087064743042, 'eval_runtime': 33.1742, 'eval_samples_per_second': 1431.896, 'eval_steps_per_second': 11.214, 'epoch': 5.0}
100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 372/372 [00:33<00:00, 11.25it/s]
Dev set results: {'eval_precision': 0.6778515737799595, 'eval_recall': 0.7499680511182109, 'eval_f1': 0.7120885787956924, 'eval_loss': 1.631087064743042, 'eval_runtime': 33.176, 'eval_samples_per_second': 1431.818, 'eval_steps_per_second': 11.213, 'epoch': 5.0}
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
/root/miniconda3/lib/python3.10/site-packages/transformers/utils/generic.py:271: FutureWarning: The input object of type 'Tensor' is an array-like implementing one of the corresponding protocols (`__array__`, `__array_interface__` or `__array_struct__`); but not a sequence (or 0-D). In the future, this object will be coerced as if it was first converted using `np.array(obj)`. To retain the old behaviour, you have to either modify the type 'Tensor', or assign to an empty array created with `np.empty(correct_shape, dtype=object)`.
  arr = np.array(obj)
100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▍| 379/380 [00:34<00:00, 11.12it/s]Test set results: {'eval_precision': 0.6528591749644381, 'eval_recall': 0.7284154393092941, 'eval_f1': 0.6885708284574069, 'eval_loss': 1.793379306793213, 'eval_runtime': 34.3833, 'eval_samples_per_second': 1414.0, 'eval_steps_per_second': 11.052, 'epoch': 5.0}
Test set results: {'eval_precision': 0.6528591749644381, 'eval_recall': 0.7284154393092941, 'eval_f1': 0.6885708284574069, 'eval_loss': 1.793379306793213, 'eval_runtime': 34.3829, 'eval_samples_per_second': 1414.018, 'eval_steps_per_second': 11.052, 'epoch': 5.0}
Test set results: {'eval_precision': 0.6528591749644381, 'eval_recall': 0.7284154393092941, 'eval_f1': 0.6885708284574069, 'eval_loss': 1.793379306793213, 'eval_runtime': 34.383, 'eval_samples_per_second': 1414.011, 'eval_steps_per_second': 11.052, 'epoch': 5.0}
100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 380/380 [00:34<00:00, 11.10it/s]
Test set results: {'eval_precision': 0.6528591749644381, 'eval_recall': 0.7284154393092941, 'eval_f1': 0.6885708284574069, 'eval_loss': 1.793379306793213, 'eval_runtime': 34.3791, 'eval_samples_per_second': 1414.175, 'eval_steps_per_second': 11.053, 'epoch': 5.0}